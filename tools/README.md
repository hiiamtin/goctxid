# Code Generation Tools

This directory contains code generation tools for the goctxid project.

## generate_reexports.go

Generates re-export code for adapter packages to eliminate code duplication.

### Purpose

Instead of manually writing the same re-export code in every adapter (fiber, echo, gin, fibernative), we use code generation to:

1. **Eliminate duplication** - Single source of truth for re-export code
2. **Ensure consistency** - All adapters have identical re-export signatures
3. **Easy maintenance** - Update template once, regenerate all adapters
4. **Clear intent** - Generated files are marked with `// Code generated` comment

### Usage

**Generate for a single adapter:**

```bash
go run tools/generate_reexports.go fiber > adapters/fiber/reexports_generated.go
```

**Generate for all adapters (recommended):**

```bash
make generate-reexports
```

This will generate:
- `adapters/fiber/reexports_generated.go`
- `adapters/echo/reexports_generated.go`
- `adapters/gin/reexports_generated.go`
- `adapters/fibernative/reexports_generated.go`

### What Gets Generated

Each generated file contains:

1. **Re-exported constants:**
   - `DefaultHeaderKey`

2. **Re-exported generator variables:**
   - `DefaultGenerator`
   - `FastGenerator`

3. **Re-exported functions (context-based adapters only):**
   - `FromContext(ctx context.Context) (string, bool)`
   - `MustFromContext(ctx context.Context) string`
   - `NewContext(ctx context.Context, correlationID string) context.Context`

**Note:** The `fibernative` adapter does NOT re-export context functions because it stores correlation IDs in `c.Locals()`, not in `context.Context`. See the "Fibernative Special Case" section below.

### Example Generated Code

```go
// Code generated by tools/generate_reexports.go. DO NOT EDIT.

package fiber

import (
	"context"
	"github.com/hiiamtin/goctxid"
)

// Re-exported constants from goctxid package for convenience
const (
	DefaultHeaderKey = goctxid.DefaultHeaderKey
)

// Re-exported generator functions from goctxid package for convenience
var (
	DefaultGenerator = goctxid.DefaultGenerator
	FastGenerator = goctxid.FastGenerator
)

// Re-exported functions from goctxid package for convenience
func FromContext(ctx context.Context) (string, bool) {
	return goctxid.FromContext(ctx)
}

func MustFromContext(ctx context.Context) string {
	return goctxid.MustFromContext(ctx)
}

func NewContext(ctx context.Context, correlationID string) context.Context {
	return goctxid.NewContext(ctx, correlationID)
}
```

### Fibernative Special Case

The `fibernative` adapter uses a different template that **excludes context functions**:

**Why?**

- Fibernative stores correlation IDs in `c.Locals()`, NOT in `context.Context`
- Re-exporting `FromContext()`, `MustFromContext()`, `NewContext()` would be misleading
- These functions would always return empty values since nothing is stored in context
- Fiber recycles contexts, making them unsafe for goroutine access

**What fibernative re-exports:**

- ✅ `DefaultHeaderKey` - Still useful
- ✅ `DefaultGenerator` - Still useful
- ✅ `FastGenerator` - Still useful
- ❌ `FromContext()` - NOT re-exported (would return empty)
- ❌ `MustFromContext()` - NOT re-exported (would return empty)
- ❌ `NewContext()` - NOT re-exported (fibernative doesn't use context)

**Fibernative users should use:**

- `FromLocals(c *fiber.Ctx)` - Get from c.Locals()
- `MustFromLocals(c *fiber.Ctx)` - Get from c.Locals() or empty string
- `FromLocalsWithKey(c *fiber.Ctx, key string)` - Get with custom key
- `MustFromLocalsWithKey(c *fiber.Ctx, key string)` - Get with custom key or empty string

**If you need context-based storage for goroutine safety, use `adapters/fiber` instead.**

### When to Regenerate

Regenerate the files when:

1. Adding new functions to the base `goctxid` package that should be re-exported
2. Adding new constants or variables to re-export
3. Creating a new adapter package
4. Modifying the re-export template

### Design Pattern

This follows the **Code Generation** pattern commonly used in Go:

- **Pros:**
  - Zero runtime overhead
  - Type-safe
  - Eliminates manual duplication
  - Easy to maintain
  - Clear which code is generated vs hand-written

- **Cons:**
  - Requires regeneration step (but automated via Makefile)
  - One more tool to understand

### Alternative Approaches Considered

1. **Manual re-exports** (previous approach)
   - ❌ Code duplication across all adapters
   - ❌ Easy to forget updating one adapter
   - ✅ No build step required

2. **Interface-based polymorphism**
   - ❌ Runtime overhead
   - ❌ Over-engineering for this use case
   - ❌ Not idiomatic Go

3. **Functional options pattern**
   - ⚠️ More complex
   - ⚠️ Still requires some duplication

**Conclusion:** Code generation provides the best balance of simplicity, maintainability, and performance.

## Future Tools

Potential future code generation tools:

- `generate_adapter.go` - Scaffold a new adapter package
- `generate_tests.go` - Generate boilerplate test code
- `generate_benchmarks.go` - Generate benchmark code for new features

